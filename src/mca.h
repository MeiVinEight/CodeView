#ifndef MCA_H
#define MCA_H

#include <WinType.h>

void *__cdecl memcpy(void *, const void *, QWORD);
void *__cdecl memset(void *, int, QWORD);
#pragma intrinsic(memcpy)
#pragma intrinsic(memset)

#define  _ENABLE_RAW_BYTES 1
#define  _ENABLE_VEX_INFO  1

enum supported_architecture
{
	X86 = 1,
	X64 = 2
};

enum decode_status
{
	MCA_ERROR = 0,
};

#define ALL (X86 | X64)

//
// instruction prefix look-up table
static size_t x86_64_prefix[256] = {
	//       00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F
	/* 00 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ALL,
	/* 10 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 20 */ 0, 0, 0, 0, 0, 0, ALL, 0, 0, 0, 0, 0, 0, 0, ALL, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, ALL, 0, 0, 0, 0, 0, 0, 0, ALL, 0,
	/* 40 */ X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, X64, // REX prefixes
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, ALL, ALL, ALL, ALL, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ ALL, 0, ALL, ALL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

//
// 1-byte lookup table
//
#define X87_FPU  2

static size_t modrm_1b[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
	/* 10 */ 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
	/* 20 */ 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
	/* 30 */ 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,
	/* 40 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, // 2 = Coprocessor Escape
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1
};

#define   b   1 // byte
#define   v   2 // word, dword or qword (64bit mode), depending on OS attribute
#define   z   3 // word for 16bit OS or dword for 32/64-bit OS
#define   p   4 // 32-bit, 48-bit, or 80-bit pointer, depending on operand-size attribute
#define   z1  6 // word for 16bit OS or dword for 32/64-bit OS
#define   w   7 // word
#define   wb  8 // word, byte
#define   gr3b  9 // byte (imm exists only if mod.reg == 0)
#define   gr3z  10 // word, dword depending on OS (imm exists only if mod.reg == 0)

static size_t imm_byte_1b[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 0, 0, 0, 0, b, z, 0, 0, 0, 0, 0, 0, b, z, 0, 0,
	/* 10 */ 0, 0, 0, 0, b, z, 0, 0, 0, 0, 0, 0, b, z, 0, 0,
	/* 20 */ 0, 0, 0, 0, b, z, 0, 0, 0, 0, 0, 0, b, z, 0, 0,
	/* 30 */ 0, 0, 0, 0, b, z, 0, 0, 0, 0, 0, 0, b, z, 0, 0,
	/* 40 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, 0, 0, 0, 0, z, z, b, b, 0, 0, 0, 0,
	/* 70 */ b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b,
	/* 80 */ b, z, b, b, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, p, 0, 0, 0, 0, 0,
	/* A0 */ z1, z1, z1, z1, 0, 0, 0, 0, b, z, 0, 0, 0, 0, 0, 0,
	/* B0 */ b, b, b, b, b, b, b, b, v, v, v, v, v, v, v, v,
	/* C0 */ b, b, w, 0, 0, 0, b, z, wb, 0, w, 0, 0, b, 0, 0,
	/* D0 */ 0, 0, 0, 0, b, b, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* E0 */ b, b, b, b, b, b, b, b, z, z, p, b, 0, 0, 0, 0,
	/* F0 */ 0, 0, 0, 0, 0, 0, gr3b, gr3z, 0, 0, 0, 0, 0, 0, 0, 0
};

/*
 * first byte:
 *   - 1: 1-byte
 *   - 2: 4-byte
 *
 * second byte (LSB):
 *   - 1: Jcc
 *   - 2: JMP
 *
 */
#define j1  0x12
#define j2  0x22
#define jc1 0x11
#define jc2 0x21

// check if the OP is Jcc or JMP
static size_t op1b_labels[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 10 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 20 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 40 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1, jc1,
	/* 80 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, j2, 0, j1, 0, 0, 0, 0,
	/* F0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

//
// 2-byte OP look-up table

// 0x0f
#define  OE   0x01
// 0x66 0x0f
#define  O66  0x02
// 0xf2 0x0f
#define  OF2  0x04
// 0xf3 0x0f
#define  OF3  0x08

#define  P1   (OE)
#define  P2   (O66 | OE)
#define  P4   (OF3 | OE)
#define  P5   (O66 | OF2)
#define  P6   (OE  | O66 | OF3)
#define  P7   (OE  | O66 | OF2 | OF3)
#define  P8   (O66 | OF2 | OF3)

static size_t modrm_2b[256] = {
	//       00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ P1, P1, P1, P1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 10 */ P7, P7, P7, P2, P2, P2, P6, P2, P1, 0, 0, 0, 0, 0, 0, P1,
	/* 20 */ P1, P1, P1, P1, 0, 0, 0, 0, P2, P2, P7, P2, P7, P7, P2, P2,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 40 */ P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1,
	/* 50 */ P2, P7, P4, P4, P2, P2, P2, P2, P7, P7, P7, P6, P7, P7, P7, P7,
	/* 60 */ P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, O66, O66, P2, P2,
	/* 70 */ P7, P1, P1, P1, P2, P2, P2, P1, P1, P1, 0, 0, P5, P5, P6, P6,
	/* 80 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1, P1,
	/* A0 */ 0, 0, 0, P1, P1, P1, 0, 0, 0, 0, 0, P1, P1, P1, P1, P1,
	/* B0 */ P1, P1, P1, P1, P1, P1, P1, P1, OF3, P1, P1, P1, P4, P4, P1, P1,
	/* C0 */ P1, P1, P7, P1, P2, P2, P2, P1, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ P5, P2, P2, P2, P2, P2, P8, P2, P2, P2, P2, P2, P2, P2, P2, P2,
	/* E0 */ P2, P2, P2, P2, P2, P2, P8, P2, P2, P2, P2, P2, P2, P2, P2, P2,
	/* F0 */ OF2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, 0
};

static size_t imm_byte_2b[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 10 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 20 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 40 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ b, b, b, b, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ z, z, z, z, z, z, z, z, z, z, z, z, z, z, z, z,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 0, 0, b, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, b, 0, b, b, b, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

// check if the OP is Jcc or JMP
static size_t op2b_labels[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 10 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 20 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 40 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2, jc2,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

//
// 3-byte OP look-up table

#define OP3 (OE | OF2 | O66)
#define OP2 (OE | OF2 | OF3)
#define OP4 (O66 | OF2 | OF3)

//
// 3-byte OP look-up table (0x38)
static size_t modreg_3b_38[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, P2, O66, O66, O66, O66,
	/* 10 */ O66, 0, 0, O66, O66, O66, O66, O66, 0, 0, 0, 0, O66, O66, O66, 0,
	/* 20 */ O66, O66, O66, O66, O66, O66, 0, 0, O66, O66, O66, O66, O66, O66, O66, O66,
	/* 30 */ O66, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66,
	/* 40 */ O66, O66, 0, 0, 0, O66, O66, O66, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ O66, O66, O66, 0, 0, 0, 0, 0, 0, 0, 0, 0, O66, 0, O66, 0,
	/* 90 */ O66, O66, O66, O66, 0, 0, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66,
	/* A0 */ 0, 0, 0, 0, 0, 0, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66,
	/* B0 */ 0, 0, 0, 0, 0, 0, O66, O66, O66, O66, O66, O66, O66, O66, O66, O66,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, O66, O66, O66, O66, O66, O66, O66, O66,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, O66, O66, O66, O66, O66,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, O66, O66, O66, O66, O66,
	/* F0 */ OP3, OP3, OE, 0, 0, OP2, OP4, P7, 0, 0, 0, 0, 0, 0, 0, 0
};

static size_t imm_byte_3b_38[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 10 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 20 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 40 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

#define OP5 (OE | O66)

//
// 3-byte OP look-up table (0x3A)

static size_t modreg_3b_3A[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ O66, O66, O66, 0, O66, O66, O66, 0, O66, O66, O66, O66, O66, O66, O66, OP5,
	/* 10 */ 0, 0, 0, 0, O66, O66, O66, O66, O66, O66, 0, 0, 0, O66, 0, 0,
	/* 20 */ O66, O66, O66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, O66, O66, 0, 0, 0, 0, 0, 0,
	/* 40 */ O66, O66, O66, 0, O66, 0, O66, 0, 0, 0, O66, O66, O66, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ O66, O66, O66, O66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, O66, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, O66,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ OF2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static size_t imm_byte_3b_3A[256] = {
	//      00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
	/* 00 */ 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,
	/* 10 */ 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,
	/* 20 */ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 30 */ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
	/* 40 */ 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0,
	/* 50 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 60 */ 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 70 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 80 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* 90 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* A0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* B0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* C0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
	/* D0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
	/* E0 */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	/* F0 */ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

enum jmp_type
{
	JCC_SHORT = 1,  // 1-byte JCC
	JCC_FAR = 2,  // 2-byte JCC, 4bytes imm
	JMP_SHORT = 4,  // 1-byte JMP
	JMP_FAR = 8,  // 4-byte JMP
};

enum prefixes
{
	ES = 1,  // 0x26
	CS = 2,  // 0x2E
	SS = 4,  // 0x36
	DS = 8,  // 0x3E
	FS = 16, // 0x64
	GS = 32, // 0x65
	OS = 64, // 0x66
	AS = 128,// 0x67
	REPNE = 256,
	REPE = 512,
	OP64 = 1024,
	VEX = 2048
};

enum instruction_feature
{
	PREFIX = 1,
	ESCAPE = 2, // 0x0F
	OP = 4,
	OP3B = 8,
	MODRM = 16,
	SIB = 32,
	REX = 64,
	DISP = 128,
	IMM = 512,
	FPU = 1024,
};

/*
 * VEX FORMAT
 *
 * 3-byte VEX bit   7      0 765 4    0 7 6  3 2  0
 *                  11000100 RXB m-mmmm W vvvv L pp
 *
 * 2-byte VEX bit   7      0 7 6  3 2  0
 *                  11000101 R vvvv L pp
 *
 * pp: equivalent to a SIMD prefix
 *      00 : None
 *      01 : 0x66
 *      02 : 0xF3
 *      03 : 0xF2
 *
 * m-mmmm:
 *      00000: Reserved for future use (will #UD)
 *      00001: implied 0F leading opcode byte
 *      00010: implied 0F 38 leading opcode bytes
 *      00011: implied 0F 3A leading opcode bytes
 *      00100-11111: Reserved for future use (will #UD)
 *
 */

#ifdef _ENABLE_VEX_INFO
struct vex_info
{
	struct
	{
		BYTE type;
		union
		{
			struct byte2
			{
				BYTE vex_pp: 2;
				BYTE vex_l: 1;
				BYTE vex_v: 4;
				BYTE vex_r: 1;
			} vexc5b;
			BYTE val5;
		};
		union
		{
			struct byte3
			{
				BYTE vex_m: 5;
				BYTE vex_b: 1;
				BYTE vex_x: 1;
				BYTE vex_r: 1;

				BYTE vex_pp: 2;
				BYTE vex_l: 1;
				BYTE vex_v: 4;
				BYTE vex_w: 1;
			} vexc4b;
			WORD val4;
		};
	};
};
#endif

struct instruction
{
	QWORD disp;
	QWORD imm;
	QWORD label;

#ifdef _ENABLE_VEX_INFO
	struct vex_info _vex;
#endif

#ifdef _ENABLE_RAW_BYTES
	BYTE instr[15];
#endif

	BYTE prefixes[4];
	BYTE op[3];
	BYTE op_len;

	union
	{
		struct
		{
			BYTE rm: 3;
			BYTE reg: 3;
			BYTE mod: 2;
		} bits;
		BYTE value;
	} modrm;

	union
	{
		struct
		{
			BYTE rex_b: 1;
			BYTE rex_x: 1;
			BYTE rex_r: 1;
			BYTE rex_w: 1;
		} bits;
		BYTE value;
	} rex;

	union
	{
		struct
		{
			BYTE base: 3;
			BYTE index: 3;
			BYTE scaled: 2;
		} bits;
		BYTE value;
	} sib;

	BYTE vex[3];

	int length;
	int disp_len;
	int imm_len;

	WORD set_prefix; // bit mask
	WORD set_field;
	BYTE jcc_type;

	BYTE vex_cnt;
	BYTE prefix_cnt;
};


//
// Functions
//
int mca_decode(struct instruction *instr, enum supported_architecture arch, char *data_src, int offset);
void mca_decode_modrm(struct instruction *instr, enum supported_architecture arch, const char *data_src, const size_t *modrmTable, const size_t *immTable, const size_t *jcc_table);
int mca_check_sib(BYTE mod, BYTE rm);
int mca_displacement_size(BYTE mod, BYTE rm);
int mca_imm_size(struct instruction *instr, size_t val, enum supported_architecture arch);
int mca_decode_2b(struct instruction *instr, enum supported_architecture arch, const char *data_src);
int mca_vex_size(struct instruction *instr, enum supported_architecture arch, const char *data);
void mca_vex_decode(struct instruction *instr, enum supported_architecture arch, const char *data, BYTE vex_size);

#endif //MCA_H
